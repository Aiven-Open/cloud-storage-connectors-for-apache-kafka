# Configuration Strategy Overview

The Kafka Connector configuration strategy works well for individual connectors.  However, our strategy is to share common fragments between connectors. So, for example the sink and source Azure connectors share common code to connect to azure, however each has a different set of data to configure for sink where a distribution of files is required, and source where unmarshalling data is required.  To solve this problem we have introduced config fragments.

Config fragments encapsulate logical fragments of configuration that may be used across multiple Connectors or across the source and sink of a connector pair.  They generally deal with a specific set of configuration options, for example file names.  Each config fragment has four responsibilities.

1. Add the `ConfigKey` definitions to the `ConfigDef` object.
2. Verify that configuration settings do not conflict between options under the control of the fragment.
3. Provide standard access to the configuration options.
4. Optionally provide a setter to make setting values for testing easier.

Configurations should extend either SinkCommonConfig or SourceCommonConfig and should have an associated **final** configuration definition class that extends SinkCommonConfig.SinkCommonConfigDef or SourceCommonConfig.SourceCommonConfigDef as appropriate.  The constructor for the Configuration should take the configuration definition class as the first argument.  If the definition utilizes any fragments, instances should be constructed in the configuration constructor, and they should be delegated as appropriate.

The configuration definition class should use Fragments to define configuration options where the options are shared across connectors, or may define the configuration options directly. Any directly defind configuration option should have a package private static string containing the configuration option name.  In addition, the configuration definition should override the `Map<String, ConfigValue> multiValidate(final Map<String, ConfigValue> valueMap)` method to perform validation across the 
 definition variables.  This method should call the `super` version first.  An example from the `AzureBlobSinkConfigDef` class is 

```java
    @Override
    public Map<String, ConfigValue> multiValidate(final Map<String, ConfigValue> valueMap) {
        final Map<String, ConfigValue> result = super.multiValidate(valueMap);
        final FragmentDataAccess dataAccess = FragmentDataAccess.from(result);
        new AzureBlobConfigFragment(dataAccess).validate(result);
        return result;
    }
```


# Fragment functionality

## Adding the ConfigKey definitions

Config fragments should implement a static `update(ConfigDef)` method that will append the `ConfigKey`s that the fragment is responsible for to the `ConfigDef` argument.  In some cases an additional argument may need to be added to the update method.  For example the `FileNameFragment` changes the `ConfigKey`s that it adds based on whether the configuration is for a sink or a source connector.

The `ConfigKey`s that are added should lbe fully formed and include any required validators and recommenders.  If a `Validator` is used it is important that the when `toString()` is called on the validator it returns the limits of the validation.  For example the default `ConfigDef.Range` validator returns the string "[lowrange...highrange]" to indicate the valid ranges.

## Verify that configuration settings do not conflict

The Config fragment implements a `validate(final Map<String, ConfigValue> configMap)` method.  By default, this method does nothing.  The purpose of the method is to add any error messages that are generated by conflicts in settings.  For example in the FileNameFragment the file name can not be determined except by examining the values for `file.name.template`, `file.compression.type` and potentially the default file name template.  Not until the file name is known can the template parser determine if there is an error in the configuration. The `validate(final Map<String, ConfigValue> configMap)` determines if there is an error and if so adds it to the `errorMessages` property of the `ConfigValue` that is associated with the `file.name.template` property.

The `validate` implementation simply updates the `configMap`.  It should not throw an exception.  Most exceptions should be caught and their messages added to the `errorMessages`.

## Provide standard access

Often the configuration definition specifies a string when the value that is desired may be a different class not supported natively by Kafka Connect.  For example in the `FileNameFragment` the `file.compression.type` is defined as a string, however the desired value is an instance of `CompressionType` therefore the implementation of `getCompressionType()` in `FileNameFragment` returns a `CompressionType`.  All configurations that use the FileNameFragment simply construct an instance of `FileNameFragment` and delegate calls to `getCompressionType()` to the fragment.  This ensures that the processing of the configuration options is consistent across the connectors.

In addition, this strategy means that the name for the configuration options is, except in a few cases, limited to the fragment and the fragment test suite.  Using this strategy allows us to deprecate older configuration options without having to change multiple classes that need to utilize the configuration value.

## Optionally provide a setter

When writing tests it is important to make the code readable.  In many cases we want to set some values in a configuration so that some interdependence can be tested.  The setter is a class that wraps a `Map<String, String>` and sets the values within the map.  For example `FileNameFragment` has a `Setter` class accessed by calling `FileNameFragment.setter(map)`.  This returns a fluent setter that will accept a CompressionType to set the `file.compression.type` in the map.  The following example sets the compression property and the number of records per file. in the properties.

```java
Map<String, String> properties = new HashMap<>();
FileNameFragment.setter(properties).fileCompression(CompressionType.GZIP).maxRecordsPerFile(5);
```